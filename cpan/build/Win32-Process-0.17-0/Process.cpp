/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.40 from the
 * contents of Process.xs. Do not edit this file, edit Process.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Process.xs"
#include <stdlib.h>		// avoid BCC-5.0 brainmelt
#include <math.h>		// avoid VC-5.0 brainmelt
#include "Process.hpp"
#define WIN32_LEAN_AND_MEAN
#include <windows.h>

#if defined(__cplusplus)
#   include <stdlib.h>
extern "C" {
#endif

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.H"

#include "ppport.h"

#ifndef ABOVE_NORMAL_PRIORITY_CLASS
#   define ABOVE_NORMAL_PRIORITY_CLASS       0x00008000
#endif
#ifndef BELOW_NORMAL_PRIORITY_CLASS
#   define BELOW_NORMAL_PRIORITY_CLASS       0x00004000
#endif

static BOOL
Create(cProcess* &cP, char* szAppName, char* szCommLine, DWORD Inherit,
       DWORD CreateFlags, char* szCurrDir)
{
    BOOL bRetVal;
    void *env = NULL;
#ifdef PERL_IMPLICIT_SYS
    env = PerlEnv_get_childenv();
#endif
    cP = NULL;
    try {
	cP = (cProcess*)new cProcess(szAppName,szCommLine,Inherit,CreateFlags,
                                     env,szCurrDir);
        bRetVal = cP->bRetVal;
    }
    catch (...) {
        bRetVal = FALSE;
    }
#ifdef PERL_IMPLICIT_SYS
    PerlEnv_free_childenv(env);
#endif
    return bRetVal;
}

static BOOL
Open_(cProcess * &cP, DWORD pid, DWORD Inherit)
{
    cP = NULL;
    try {
	cP = (cProcess *) new cProcess(pid, Inherit);
    }
    catch (...) {
	return(FALSE);
    }
    return(cP->bRetVal);
}



static double
constant(char* name)
{
    errno = 0;
    switch (*name) {
    case 'A':
	if (strEQ(name, "ABOVE_NORMAL_PRIORITY_CLASS"))
#ifdef ABOVE_NORMAL_PRIORITY_CLASS
	    return ABOVE_NORMAL_PRIORITY_CLASS;
#else
	    goto not_there;
#endif
	break;
    case 'B':
	if (strEQ(name, "BELOW_NORMAL_PRIORITY_CLASS"))
#ifdef BELOW_NORMAL_PRIORITY_CLASS
	    return BELOW_NORMAL_PRIORITY_CLASS;
#else
	    goto not_there;
#endif
	break;
    case 'C':
	if (strEQ(name, "CREATE_DEFAULT_ERROR_MODE"))
#ifdef CREATE_DEFAULT_ERROR_MODE
	    return CREATE_DEFAULT_ERROR_MODE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CREATE_NEW_CONSOLE"))
#ifdef CREATE_NEW_CONSOLE
	    return CREATE_NEW_CONSOLE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CREATE_NEW_PROCESS_GROUP"))
#ifdef CREATE_NEW_PROCESS_GROUP
	    return CREATE_NEW_PROCESS_GROUP;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CREATE_NO_WINDOW"))
#ifdef CREATE_NO_WINDOW
	    return CREATE_NO_WINDOW;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CREATE_SEPARATE_WOW_VDM"))
#ifdef CREATE_SEPARATE_WOW_VDM
	    return CREATE_SEPARATE_WOW_VDM;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CREATE_SUSPENDED"))
#ifdef CREATE_SUSPENDED
	    return CREATE_SUSPENDED;
#else
	    goto not_there;
#endif
	if (strEQ(name, "CREATE_UNICODE_ENVIRONMENT"))
#ifdef CREATE_UNICODE_ENVIRONMENT
	    return CREATE_UNICODE_ENVIRONMENT;
#else
	    goto not_there;
#endif
	break;
    case 'D':
	if (strEQ(name, "DEBUG_ONLY_THIS_PROCESS"))
#ifdef DEBUG_ONLY_THIS_PROCESS
	    return DEBUG_ONLY_THIS_PROCESS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DEBUG_PROCESS"))
#ifdef DEBUG_PROCESS
	    return DEBUG_PROCESS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "DETACHED_PROCESS"))
#ifdef DETACHED_PROCESS
	    return DETACHED_PROCESS;
#else
	    goto not_there;
#endif
	break;
    case 'E':
	break;
    case 'F':
	break;
    case 'G':
	break;
    case 'H':
	if (strEQ(name, "HIGH_PRIORITY_CLASS"))
#ifdef HIGH_PRIORITY_CLASS
	    return HIGH_PRIORITY_CLASS;
#else
	    goto not_there;
#endif
	break;
    case 'I':
	if (strEQ(name, "IDLE_PRIORITY_CLASS"))
#ifdef IDLE_PRIORITY_CLASS
	    return IDLE_PRIORITY_CLASS;
#else
	    goto not_there;
#endif
	if (strEQ(name, "INFINITE"))
#ifdef INFINITE
	    return INFINITE;
#else
	    goto not_there;
#endif
	break;
    case 'J':
	break;
    case 'K':
	break;
    case 'L':
	break;
    case 'M':
	break;
    case 'N':
	if (strEQ(name, "NORMAL_PRIORITY_CLASS"))
#ifdef NORMAL_PRIORITY_CLASS
	    return NORMAL_PRIORITY_CLASS;
#else
	    goto not_there;
#endif
	break;
    case 'O':
	break;
    case 'P':
	break;
    case 'Q':
	break;
    case 'R':
	if (strEQ(name, "REALTIME_PRIORITY_CLASS"))
#ifdef REALTIME_PRIORITY_CLASS
	    return REALTIME_PRIORITY_CLASS;
#else
	    goto not_there;
#endif
	break;
    case 'S':
	if (strEQ(name, "STILL_ACTIVE"))
#ifdef STILL_ACTIVE
	    return STILL_ACTIVE;
#else
	    goto not_there;
#endif
	break;
    case 'T':
	if (strEQ(name, "THREAD_PRIORITY_ABOVE_NORMAL"))
#ifdef THREAD_PRIORITY_ABOVE_NORMAL
	    return THREAD_PRIORITY_ABOVE_NORMAL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "THREAD_PRIORITY_BELOW_NORMAL"))
#ifdef THREAD_PRIORITY_BELOW_NORMAL
	    return THREAD_PRIORITY_BELOW_NORMAL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "THREAD_PRIORITY_ERROR_RETURN"))
#ifdef THREAD_PRIORITY_ERROR_RETURN
	    return THREAD_PRIORITY_ERROR_RETURN;
#else
	    goto not_there;
#endif
	if (strEQ(name, "THREAD_PRIORITY_HIGHEST"))
#ifdef THREAD_PRIORITY_HIGHEST
	    return THREAD_PRIORITY_HIGHEST;
#else
	    goto not_there;
#endif
	if (strEQ(name, "THREAD_PRIORITY_IDLE"))
#ifdef THREAD_PRIORITY_IDLE
	    return THREAD_PRIORITY_IDLE;
#else
	    goto not_there;
#endif
	if (strEQ(name, "THREAD_PRIORITY_LOWEST"))
#ifdef THREAD_PRIORITY_LOWEST
	    return THREAD_PRIORITY_LOWEST;
#else
	    goto not_there;
#endif
	if (strEQ(name, "THREAD_PRIORITY_NORMAL"))
#ifdef THREAD_PRIORITY_NORMAL
	    return THREAD_PRIORITY_NORMAL;
#else
	    goto not_there;
#endif
	if (strEQ(name, "THREAD_PRIORITY_TIME_CRITICAL"))
#ifdef THREAD_PRIORITY_TIME_CRITICAL
	    return THREAD_PRIORITY_TIME_CRITICAL;
#else
	    goto not_there;
#endif
	break;
    case 'U':
	break;
    case 'V':
	break;
    case 'W':
	break;
    case 'X':
	break;
    case 'Y':
	break;
    case 'Z':
	break;
    }
    errno = EINVAL;
    return 0;

not_there:
    errno = ENOENT;
    return 0;
}

#if defined(__cplusplus)
}
#endif


#line 301 "Process.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 445 "Process.c"

XS_EUPXS(XS_Win32__Process_Create); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_Create)
{
    dVAR; dXSARGS;
    if (items != 6)
       croak_xs_usage(cv,  "cP, appname_sv, cmdline_sv, inherit, flags, curdir");
    {
	cProcess *	cP = NULL;
	SV *	appname_sv = ST(1)
;
	SV *	cmdline_sv = ST(2)
;
	BOOL	inherit = (bool)SvTRUE(ST(3))
;
	DWORD	flags = (DWORD)SvNV(ST(4))
;
	char *	curdir = (char *)SvPV_nolen(ST(5))
;
	BOOL	RETVAL;
#line 305 "Process.xs"
    char *appname = SvOK(appname_sv) ? SvPV_nolen(appname_sv) : NULL;
    char *cmdline = SvOK(cmdline_sv) ? SvPV_nolen(cmdline_sv) : NULL;
#line 469 "Process.c"
#line 308 "Process.xs"
    RETVAL = Create(cP, appname, cmdline, inherit, flags, curdir);
#line 472 "Process.c"
	sv_setref_pv(ST(0), "Win32::Process", (void*)cP);
	SvSETMAGIC(ST(0));
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_Open); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_Open)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "cP, pid, inherit");
    {
	cProcess *	cP = NULL;
	DWORD	pid = (DWORD)SvNV(ST(1))
;
	BOOL	inherit = (bool)SvTRUE(ST(2))
;
	BOOL	RETVAL;
#line 320 "Process.xs"
    RETVAL = Open_(cP, pid, inherit);
#line 496 "Process.c"
	sv_setref_pv(ST(0), "Win32::Process", (void*)cP);
	SvSETMAGIC(ST(0));
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_constant); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_constant)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "name");
    {
	char *	name = (char *)SvPV_nolen(ST(0))
;
	double	RETVAL;
	dXSTARG;

	RETVAL = constant(name);
	XSprePUSH; PUSHn((double)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_Kill); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_Kill)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "cP, exitcode");
    {
	cProcess *	cP;
	unsigned int	exitcode = (unsigned int)SvUV(ST(1))
;
	BOOL	RETVAL;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 336 "Process.xs"
    RETVAL = cP->Kill(exitcode);
#line 545 "Process.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_Suspend); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_Suspend)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cP");
    {
	cProcess *	cP;
	BOOL	RETVAL;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 344 "Process.xs"
    RETVAL = cP->Suspend();
#line 571 "Process.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_Resume); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_Resume)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cP");
    {
	cProcess *	cP;
	BOOL	RETVAL;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 352 "Process.xs"
    RETVAL = cP->Resume();
#line 597 "Process.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_GetPriorityClass); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_GetPriorityClass)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "cP, priorityclass");
    {
	cProcess *	cP;
	DWORD	priorityclass;
	BOOL	RETVAL;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 361 "Process.xs"
    RETVAL = cP->GetPriorityClass(&priorityclass);
#line 624 "Process.c"
	sv_setnv(ST(1), (NV)priorityclass);
	SvSETMAGIC(ST(1));
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_SetPriorityClass); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_SetPriorityClass)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "cP, priorityclass");
    {
	cProcess *	cP;
	DWORD	priorityclass = (DWORD)SvNV(ST(1))
;
	BOOL	RETVAL;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 372 "Process.xs"
    RETVAL = cP->SetPriorityClass(priorityclass);
#line 654 "Process.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_GetProcessAffinityMask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_GetProcessAffinityMask)
{
    dVAR; dXSARGS;
    if (items != 3)
       croak_xs_usage(cv,  "cP, processAffinityMask, systemAffinityMask");
    {
	cProcess *	cP;
	DWORD_PTR	processAffinityMask;
	DWORD_PTR	systemAffinityMask;
	BOOL	RETVAL;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 383 "Process.xs"
    RETVAL = cP->GetProcessAffinityMask(&processAffinityMask,&systemAffinityMask);
#line 682 "Process.c"
	sv_setuv(ST(1), (UV)processAffinityMask);
	SvSETMAGIC(ST(1));
	sv_setuv(ST(2), (UV)systemAffinityMask);
	SvSETMAGIC(ST(2));
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_SetProcessAffinityMask); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_SetProcessAffinityMask)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "cP, processAffinityMask");
    {
	cProcess *	cP;
	DWORD	processAffinityMask = (DWORD)SvNV(ST(1))
;
	BOOL	RETVAL;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 395 "Process.xs"
    RETVAL = cP->SetProcessAffinityMask(processAffinityMask);
#line 714 "Process.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_GetExitCode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_GetExitCode)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "cP, exitcode");
    {
	cProcess *	cP;
	DWORD	exitcode;
	BOOL	RETVAL;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 405 "Process.xs"
    RETVAL = cP->GetExitCode(&exitcode);
#line 741 "Process.c"
	sv_setnv(ST(1), (NV)exitcode);
	SvSETMAGIC(ST(1));
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_DESTROY)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cP");
    {
	cProcess *	cP;

	if (SvROK(ST(0))) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    Perl_croak_nocontext("%s: %s is not a reference",
			"Win32::Process::DESTROY",
			"cP")
;
#line 415 "Process.xs"
    delete cP;
#line 770 "Process.c"
    }
    XSRETURN_EMPTY;
}


XS_EUPXS(XS_Win32__Process_Wait); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_Wait)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "cP, timeout");
    {
	cProcess *	cP;
	DWORD	timeout = (DWORD)SvNV(ST(1))
;
	BOOL	RETVAL;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 423 "Process.xs"
    RETVAL = (cP->Wait(timeout) == WAIT_OBJECT_0);
#line 797 "Process.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_get_process_handle); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_get_process_handle)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cP");
    {
	cProcess *	cP;
	IV	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 432 "Process.xs"
    RETVAL = reinterpret_cast<IV>(cP->GetProcessHandle());
#line 824 "Process.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_GetProcessID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_GetProcessID)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "cP");
    {
	cProcess *	cP;
	DWORD	RETVAL;
	dXSTARG;

	if (sv_derived_from(ST(0), "Win32::Process")) {
	    IV tmp = SvIV((SV*)SvRV(ST(0)));
	    cP = INT2PTR(cProcess *,tmp);
	}
	else
	    croak("cP is not of type Win32::Process")
;
#line 440 "Process.xs"
    RETVAL = cP->GetProcessID();
#line 851 "Process.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_KillProcess); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_KillProcess)
{
    dVAR; dXSARGS;
    if (items != 2)
       croak_xs_usage(cv,  "pid, exitcode");
    {
	DWORD	pid = (DWORD)SvNV(ST(0))
;
	unsigned int	exitcode = (unsigned int)SvUV(ST(1))
;
	BOOL	RETVAL;
#line 449 "Process.xs"
    {
	HANDLE ph = OpenProcess(PROCESS_DUP_HANDLE        |
	                        PROCESS_QUERY_INFORMATION |
	                        PROCESS_SET_INFORMATION   |
	                        PROCESS_TERMINATE         |
	                        SYNCHRONIZE,
	                        0, pid);
	if (ph) {
	    RETVAL = TerminateProcess(ph, exitcode);
	    if (RETVAL)
		CloseHandle(ph);
	}
    }
#line 884 "Process.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Win32__Process_GetCurrentProcessID); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Win32__Process_GetCurrentProcessID)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
	DWORD	RETVAL;
	dXSTARG;
#line 468 "Process.xs"
    RETVAL = GetCurrentProcessId();
#line 902 "Process.c"
	XSprePUSH; PUSHn((NV)RETVAL);
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Win32__Process); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Win32__Process)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Win32::Process::Create", XS_Win32__Process_Create);
        newXS_deffile("Win32::Process::Open", XS_Win32__Process_Open);
        newXS_deffile("Win32::Process::constant", XS_Win32__Process_constant);
        newXS_deffile("Win32::Process::Kill", XS_Win32__Process_Kill);
        newXS_deffile("Win32::Process::Suspend", XS_Win32__Process_Suspend);
        newXS_deffile("Win32::Process::Resume", XS_Win32__Process_Resume);
        newXS_deffile("Win32::Process::GetPriorityClass", XS_Win32__Process_GetPriorityClass);
        newXS_deffile("Win32::Process::SetPriorityClass", XS_Win32__Process_SetPriorityClass);
        newXS_deffile("Win32::Process::GetProcessAffinityMask", XS_Win32__Process_GetProcessAffinityMask);
        newXS_deffile("Win32::Process::SetProcessAffinityMask", XS_Win32__Process_SetProcessAffinityMask);
        newXS_deffile("Win32::Process::GetExitCode", XS_Win32__Process_GetExitCode);
        newXS_deffile("Win32::Process::DESTROY", XS_Win32__Process_DESTROY);
        newXS_deffile("Win32::Process::Wait", XS_Win32__Process_Wait);
        newXS_deffile("Win32::Process::get_process_handle", XS_Win32__Process_get_process_handle);
        newXS_deffile("Win32::Process::GetProcessID", XS_Win32__Process_GetProcessID);
        newXS_deffile("Win32::Process::KillProcess", XS_Win32__Process_KillProcess);
        newXS_deffile("Win32::Process::GetCurrentProcessID", XS_Win32__Process_GetCurrentProcessID);
#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

